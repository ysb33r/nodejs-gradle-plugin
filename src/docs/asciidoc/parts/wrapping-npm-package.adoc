== Wrapping NPM packages

If you are familiar with NPM just will know that many packages have some entry point script which can be used as a tool on the command-line. You are probably quite familiar with Gulp too and if you already usedh the Gulp functionality that comes with the Gulp plugin, you might be pondering doing the same approach for your favourite Node tool package.

The process if doing this is relatively straight-forward. it involved creating an extension and a resolver. Once you have these you can continue implementing your own task types.

NOTE: The following example are shown in Groovy, but you can use Java or Kotlin for your implementation if you wish.

This approach can be used in a gradle script, `buildSrc` or a standalone plugin.

=== Creating the resolver

Assume for the moment that there is a packaged tool called FooBar which you want to wrap.

Firstly create the resovler by extending the abstract base link:{api}/org/ysb33r/gradle/nodejs/pkgwrapper/AbstractPackageResolver.html[AbstractPackageResolver].

[source,groovy]
----
@CompileStatic
class FooBarResolver extends AbstractPackageResolver {

    FooBarResolver(Project project, NodeJSExtension nodeExtension, NpmExtension npmExtension) { // <1>
        super(
          null,  // <2>
          'gulp',  // <3>
          project,nodeExtension,npmExtension
        )
    }
}
----
<1> This class requires a single constructor that passes appropriate parameters to the base class. The resolver will be attached to a project and will need to know about a NodeJS and a NPM extension.
<2> If the package you are planning to wrap has a scope, add it here otherwise just use `null`.
<3> The name of the package

The next step is to create an extension which can consume the resolver.

=== Creating the extension

Continuing on the `FooBar` example from before create an extension class that extends link:{api}/org/ysb33r/gradle/nodejs/pkgwrapper/AbstractPackageWrappingExtension.html[AbstractPackageWrappingExtension].

There are three methods in protected scope that you will need to implement in addition to two contructors
[source,groovy]
----
@CompileStatic
class FooBarExtension extends AbstractPackageWrappingExtension<FooBarResolver> {

    FooBarExtension(Project project) { // <1>
        super(project)
    }

    FooBarExtension(Task task) { // <2>
        super(task)
    }

    @Override
    protected String getExtensionName() { // <3>
        'name-of-this-extension'
    }

    @Override
    protected String getEntryPoint() { // <4>
        'bin/foobar.js'
    }

    @Override
    protected FooBarResolver createResolver() { // <5>
        new FooBarResolver(getProject(),getNodeJSExtension(),getNpmExtension()) // <6>
    }
}
----
<1> Attaches the extension to a project.
<2> Attaches the extension to a task
<3> The name that this extension will be known by. This is used by the superclass to resolve project extensions when the extensions are atatched to a task.
<4> This is the entrypoint script file and must be specified relative to the package folder after installation.
<5> Creates an instance of the resolver that you crafter earlier.
<6> `getProject()` is a superclass method that knows whether the extension is attached to a project or a task and will work out the `project` instance accordingly.

You can now add methods to your extension as if necessary to reflect the functionality of the wrapped package. For instance the link:{api}/org/ysb33r/gradle/nodejs/GulpExtension.html[GulpExtension] class adds `gulpFile` and `requires` to deal with the `--gulpfile` and `--requires` parameters of `gulp.js`.

If you add methods where the returned values can be overriden in a task in a similar fashion to what can be done in `NpmTask` and `GulpTask`, you will need to add some logic to handle those cases. Here is an exmaple of how it is being done in `GulpExtension` to retrieve the value for `gulpFile`.

.GulpExtension.groovy
[source,groovy]
----
include::{sourcedir}/GulpExtension.groovy[tags=example-of-task-overriding1,indent=0]

include::{sourcedir}/GulpExtension.groovy[tags=example-of-task-overriding2,indent=0]
----
<1> If this is attached to a task, check if the value is set. Use it if it is, otherwise defer to the project extension. If this is a project extension use the local value.
<2> A helper to always resolve the correct project extension.
